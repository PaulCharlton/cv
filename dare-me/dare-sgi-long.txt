# Dare Me to Do It Again: How I Saved SGIâ€™s CXFSâ€”and Its Customers ğŸ’¾ğŸ”¥

> *"Legacy is my edge. Complexity sharpens my blade. I don't just bring systems back to lifeâ€”I make them tell the truth."* ğŸ—¡ï¸

### Prelude: Holding Up the Sky â˜ï¸ğŸ› ï¸

This story isnâ€™t about code. Itâ€™s about **customers walking out the door** ğŸšª, and the desperate call that came when **SGIâ€™s media and entertainment sales pipeline was collapsing** ğŸ“‰.

After SGI was acquired by Rackable, the CXFS engineering team had no one left who could support macOS or Windows. **Meanwhile, NetApp was devouring their client base**, offering cross-platform storage that "just worked"â€”while CXFS clients were breaking, silently corrupting files, or outright failing to interoperate across platforms. ğŸ˜¬ğŸ’£

SGI brought me in as a **principal consulting engineer**â€”not to experiment, but to **save revenue** ğŸ’°.

My original mandate: resurrect the macOS and Windows CXFS clients before more M&E accounts were lost. ğŸ§Ÿâ€â™‚ï¸ğŸ’»

What I ended up doing was more than a port. I unearthed decades of drift, rot, and false assumptions. And I gave CXFS a soul. ğŸ§¬

I gave it **truth**â€”across architectures, platforms, and every byte of Unicode. âœ¨

### Act I: Rescuing the Sales Pipeline ğŸ’¼ğŸ©º

SGI didnâ€™t bring me in for the code. They brought me in for the clients.

After the Rackable acquisition, SGI had no macOS or Windows kernel engineers left. CXFS was collapsing under its own history. Meanwhile, NetApp was walking into SGIâ€™s media and entertainment accounts and walking out with signed POs ğŸ§¾âœï¸.

The M&E sales team made the call. I got the brief: *â€œResurrect the CXFS clients. Stop the bleeding. Make us competitive again.â€* ğŸ†˜

What I did instead? I gave CXFS truth â€” byte for byte, across every OS it touched. ğŸ§ ğŸ§µ

### Act II: Resurrecting the Rot âš°ï¸ğŸ§°

My contract was scoped for 12 months. I was hired as a principal consulting engineer to fix what no one else could. ğŸ§™â€â™‚ï¸

**Months 1â€“3**: I resurrected the macOS and Windows 32-bit CXFS client drivers. The codebase hadnâ€™t built in years. Preprocessor hell. Kernel drift. ABI misalignment. And yet, I got it runningâ€”clean and stableâ€”on platforms SGI hadnâ€™t touched in a decade. âš™ï¸ğŸ§¼

**Months 4â€“6**: I rebuilt the entire thing for 64-bit. New drivers. New interface layers. Full support for Vista, NT, and modern macOS. ğŸ’ªğŸ§±

I had delivered the entire scope **in half the contracted time.** â±ï¸âœ…

### Act III: The Unicode Abyss ğŸ•³ï¸ğŸ”¤

With six months left, I asked myself: *Whatâ€™s still broken?* ğŸ¤”

A file written by a Windows client couldnâ€™t be found by a macOS editor.
A file listed by a Linux node was unreadable by a Windows app.

I dug deeper. I pulled every broken filename, every ghost file, every mismatch. ğŸ§Ÿâ€â™€ï¸ğŸ•µï¸â€â™‚ï¸

And there it was: **Unicode canonical equivalence.** ğŸ”ğŸ’¥

- Windows clients sent UTF-16 with no normalization.
- macOS enforced NFD on UTF-8.
- Linux was raw bytes.
- XFS? It just stored whatever it was given. ğŸ¤·â€â™‚ï¸

This was never going to work across platforms unless I intervened at the semantic level. ğŸ§¼ğŸ›¡ï¸

### Act IV: Building the Truth Engine âš™ï¸ğŸ“

I didnâ€™t just rely on conventions or developer discipline. I enforced encoding correctness **at compile time** ğŸ§¾ğŸ”’. Each encoding modeâ€”raw UTF-8, UTF-16 mixed, UTF-16 NFD+PUA, UTF-8 on-diskâ€”had its own unique C type. The compiler would reject any attempt to mix representations incorrectly. Compare functions only accepted the specific, pre-normalized `UTF16_NFKD` type. Memory and disk handling code required explicit conversion steps between `UTF16_NFD_PUA` and `UTF8_NFD_PUA`, enforced by the type system. This prevented subtle bugs, avoided normalization mismatches, and made correctness unskippable. ğŸ§ ğŸ’¡

I built a **Unicode fidelity engine** into CXFS.

1. **Preserve the syscall**: The original UTF-8 inputâ€”including `/`â€”was sacred. ğŸ™
2. **Convert to UTF-16**: Normalize everything in a structure-friendly encoding.
3. **Tag using Private Use Area (PUA)**: Every canonical or compatibility variant got a unique markerâ€”**before** normalization. ğŸ·ï¸
4. **Escape existing PUA values**: If the syscall stream already contained PUA characters, I escaped them into a reserved PUA range of my own, so I could safely distinguish between user input and driver-added tags. ğŸ”
5. **Normalize to NFD (or NFKD) + PUA**: All **in-memory structures used UTF-16 (ISA-endian), normalized to NFD with layered PUA tags**. ğŸ§ 
6. **Persist as UTF-8 NFD + PUA**: All **on-disk representations** were stored as UTF-8, also NFD + escaped PUA, preserving fidelity with byte-for-byte reversibility. ğŸ’¾
7. **Compare using NFKD + locale**: Equality was meaningful, culturally aware, and correct. ğŸŒ
8. **Round-trip**: When a client listed or opened a file, I reversed the PUA mapping to return the **exact bytes** they originally provided, including any pre-existing PUA codepoints. ğŸŒ€

I didn't just preserve identityâ€”I preserved *intent*. Byte-for-byte, every name was recoverable. No false positives. No silent collapses. No ghost files. ğŸ§¾âœ…

### Act V: VFS Pivot Point ğŸ”ğŸ§±

In macOS, Windows, and Linux, the syscall went to VFS. But **clustered XFS took over after mount point resolution**. ğŸ—‚ï¸

The kernel walked `/xfs_cluster`, then said, "You're on your own." ğŸ˜…

And I was. My driver received the full remaining pathâ€”**slashes and all**â€”and I preserved them without compromise. I decoded it. I tagged it. I *remembered it*. If it already had PUA codepoints from the user, I escaped them into my own internal PUA band before applying my normalization tags. ğŸ§™â€â™‚ï¸ğŸª„

All in-memory representations were kept in UTF-16 (ISA-endian), normalized to NFD + PUA. All on-disk storage was encoded in UTF-8, also normalized to NFD + PUA. This clear and deliberate separation ensured correct behavior regardless of ABI, endianess, or syscall origin. ğŸ§©ğŸ› ï¸

Canonicality didn't just happen at the segment level. It happened at the **semantic boundary** between user and cluster. ğŸ§±ğŸ”¤

And what syscall provided, **syscall got back**. ğŸ¯

### Act VI: Locking the World ğŸ”ğŸŒ

And then came file locking.

Windows and macOS clients locked files from `0` to `omega`. Always. They didnâ€™t know any better. ğŸ¤·â€â™‚ï¸

Linux clients, however, used **byte-range locks**â€”cluster-aware, fine-grained, and correct. ğŸ§¬

So I built in logic to track and translate:
- Windows/mac clients implicitly held whole-file locks.
- Linux clients played nice with ranges.

No collisions. No corruption. Just **documented behavioral boundaries**. ğŸ§¾ğŸš§

### Act VII: The Code That Never Saw Daylight ğŸŒ‘ğŸ—ƒï¸

CXFS was proprietary. Always was.

I had to treat the open-source XFS tree as upstream, and **maintain my changes downstream**, as long as the community didn't accept my patches.

My **Unicode wizardry?** It's probably still there. âœ¨ğŸ”§

Today, **HPE owns the last living copy of CXFS**, maintained by **a single engineer I worked with**. Itâ€™s frozen in place. Legacy-bound. But still runningâ€”in data centers, on military ships, and maybe even on a few SGI racks with blinking lights. ğŸš¢ğŸ§Š

You won't find my name on a GitHub commit. But if you've ever opened a file on CXFS from a different OS and had it *just work*, that was me. ğŸ«¡

### Act VIII: The Quiet Mic Drop ğŸ¤ğŸ˜

What no one at SGI ever knew â€” and what Iâ€™ve never told anyone until now â€” is this:

They were ecstatic with my work. My weekly productivity. My collaboration with the test team. I was delivering more each week than most of their full-time engineers. ğŸ“ˆğŸ‘

They assumed I was working 40 hours a week.

I wasnâ€™t. ğŸ§˜â€â™‚ï¸ğŸŒ

I was a digital nomad. Coding from beach cafÃ©s around the world. Most weeks, I logged **10â€“15 hours total**. â˜•ğŸŒ´

My contract was fixed-term, fixed-price, results-based. And I delivered. Consistently. Quietly. Completely. ğŸ’¼ğŸ’¡

Legacy is my edge. **Toe shoes optional.** ğŸ¦¶ğŸ‘Ÿ

### Coda: The Dare ğŸ¯ğŸ”¥

> â€œLegacy is not a curse. It's leverage. The past doesn't scare meâ€”it sharpens me.â€ ğŸ§ âš”ï¸

Dare me to do it again?

I already did. âœ…

Now letâ€™s talk about open-sourcing it. ğŸ—ï¸ğŸ‘

Letâ€™s free the code. ğŸ”“

Letâ€™s let my friend walk away from the job of maintaining a fossil. ğŸª¦ğŸ‘‹

Letâ€™s show the world what **Unicode truth** looks likeâ€”byte for byte, name for name, syscall in to syscall out. ğŸ”¤ğŸ’¥ğŸ“œ

â€”**[The Techguru]**


